# Claude 开发指导原则

## 核心原则

### 🚫 严格禁止的行为

1. **禁止一切简化的尝试**
   - 不允许删除文件来"简化"问题
   - 不允许跳过复杂逻辑的实现
   - 不允许用"临时解决方案"代替正确的实现
   - 问题必须从根本上解决，而不是规避

2. **禁止思考时偷懒**
   - 必须深入分析问题的根本原因
   - 不允许浅层的快速修复
   - 需要考虑完整的解决方案和边界情况
   - 必须理解代码的上下文和依赖关系

3. **禁止投机取巧的导入修改**
   - 不允许简单地把导入改成 `from swift import xxx`
   - 必须理解模块的实际功能和实现
   - 需要正确地移植或重新实现必要的功能
   - 不能因为某个模块存在就直接使用，要考虑架构的合理性

### ✅ 正确的开发方法

1. **深度分析问题**
   - 使用工具彻底搜索和理解代码结构
   - 分析依赖关系和模块间的交互
   - 理解设计意图和架构模式
   - 找到问题的根本原因

2. **完整的解决方案**
   - 实现完整的功能，不留技术债务
   - 考虑所有相关的配置和参数
   - 确保解决方案与整体架构一致
   - 测试和验证实现的正确性

3. **正确的代码移植**
   - 理解源代码的完整逻辑
   - 适配目标框架的架构和约定
   - 保持功能的完整性和正确性
   - 更新相关的配置和文档

## 具体案例教训

### 错误示例 1：删除文件简化
```bash
# ❌ 错误做法
rm simple_sft_train.py  # 删掉文件来"简化"
```
**问题**：删除文件不能解决根本问题，只是在逃避

### 错误示例 2：投机取巧的导入
```python
# ❌ 错误做法  
from swift.utils import deep_getattr, get_logger  # 直接依赖swift
```
**问题**：没有理解依赖关系，没有考虑模块的独立性

### 正确示例：完整的功能移植
```python
# ✅ 正确做法
def deep_getattr(obj, attr: str, default=None):
    """完整实现功能，避免外部依赖"""
    attrs = attr.split('.')
    for a in attrs:
        if obj is None:
            break
        if isinstance(obj, dict):
            obj = obj.get(a, default)
        else:
            obj = getattr(obj, a, default)
    return obj

from verl.utils.core.logger import get_logger
```

## 开发流程要求

1. **问题分析阶段**
   - 使用 Grep/Task 工具全面搜索相关代码
   - 理解完整的调用链和依赖关系
   - 分析配置文件和参数传递
   - 确定问题的边界和影响范围

2. **设计解决方案**
   - 设计符合架构的解决方案
   - 考虑向后兼容性和扩展性
   - 确保方案的完整性和正确性
   - 避免引入新的技术债务

3. **实现阶段**
   - 完整实现所有必要的功能
   - 正确处理边界情况和错误情况
   - 更新相关配置和文档
   - 保持代码风格和架构一致性

4. **测试验证**
   - 测试所有支持的参数和功能
   - 验证与现有系统的兼容性
   - 检查性能和资源使用情况
   - 确保没有回归问题

## 特定于 VERL 项目的要求

1. **MS-Swift 集成**
   - 理解 MS-Swift 的参数和功能
   - 正确移植到 VERL 架构中
   - 保持参数兼容性
   - 实现完整的功能映射

2. **Hydra 配置**
   - 正确更新配置模式
   - 处理所有参数映射
   - 确保配置的一致性
   - 支持动态配置覆盖

3. **FSDP 训练**
   - 理解 FSDP 的工作机制
   - 正确配置多GPU训练
   - 处理数据并行和模型并行
   - 确保训练的稳定性

4. **多模态支持**
   - 正确处理视觉-语言模型
   - 实现图像和文本的联合处理
   - 支持不同的数据格式
   - 确保模型加载的正确性

## 提醒

当遇到复杂问题时，记住：
- **不要简化，要解决**
- **不要偷懒，要深入**
- **不要投机，要正确**
- **理解问题的本质，实现完整的解决方案**

> "简化永远不是解决问题的思路" - 用户反馈
> "你这个方法实际上极其弱智，是一种偷懒的做法" - 用户反馈

## 脚本编写和环境管理规则

### 🚨 强制要求：遵循ms-swift标准格式

**verl-plus项目中的训练脚本必须与swift_examples保持一致的格式**

#### 脚本编写规范
1. **完全参考swift_examples中的对应脚本**
   - 保持相同的相对路径结构
   - 保持相同的参数格式和顺序
   - 保持相同的注释和文档风格
   - **只将 `swift sft` 改为 `verl sft`**

2. **标准格式示例**：
```bash
# 22GB
# qwen3: https://github.com/modelscope/ms-swift/blob/main/examples/train/think_model/qwen3_demo1.sh
CUDA_VISIBLE_DEVICES=0,1,2,3 \
verl sft \
    --model Qwen/Qwen2.5-7B-Instruct \
    --train_type lora \
    --dataset 'AI-ModelScope/alpaca-gpt4-data-zh#500' \
              'AI-ModelScope/alpaca-gpt4-data-en#500' \
              'swift/self-cognition#500' \
    --torch_dtype bfloat16 \
    ...
```

#### 禁止的做法
- ❌ 在脚本中添加conda环境激活逻辑（用户自己负责）
- ❌ 修改原始的ms-swift数据集格式
- ❌ 改变参数顺序或格式
- ❌ 添加额外的环境设置逻辑
- ❌ 偏离swift_examples的标准格式

#### 正确的做法  
- ✅ 完全复制swift_examples的脚本格式
- ✅ 只修改swift sft为verl sft
- ✅ 保持原始的数据集引用格式
- ✅ 用户负责在运行前激活verl环境
- ✅ 保持ms-swift的使用习惯和约定

#### 环境管理责任
- **用户责任**：在运行脚本前激活verl conda环境
- **脚本责任**：提供与ms-swift一致的使用体验
- **verl系统责任**：正确处理ms-swift格式的数据集和参数

#### 反面教训
之前的错误理解：
1. 错误地认为脚本应该自己管理环境
2. 错误地修改了数据集格式和路径
3. 错误地添加了额外的环境设置逻辑
4. 没有参考swift_examples的标准格式

**脚本格式必须与swift_examples保持一致！**

## 工具使用指南

- **Task**: 用于复杂的搜索和分析任务
- **Grep**: 用于精确的代码搜索  
- **Read**: 用于理解文件内容和结构
- **Edit/MultiEdit**: 用于精确的代码修改
- **TodoWrite**: 用于任务管理和进度跟踪

记住：工具是为了更好地理解和解决问题，而不是为了快速绕过问题。